<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planner with Altitude</title>
    
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Routing Machine -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- Leaflet Control Geocoder -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <!-- Chart.js for Elevation Profile -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body { margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; font-family: sans-serif; }
        #map { flex: 1; }
        #route-options {
            position: absolute;
            top: 10px;
            left: 50%; /* Center horizontally */
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            z-index: 1000;
            border: 1px solid #ccc;
        }
        #elevation-container { 
            height: 250px; /* Increased height for legend */
            background: #fff; 
            border-top: 1px solid #ccc; 
            padding: 10px;
            box-sizing: border-box;
            display: none;
            position: relative;
        }
        #elevation-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
        }
        #grade-stats {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }
        .route-stat-group {
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        .route-stat-group:last-child { border-bottom: none; margin-bottom: 0; }
        .route-title { font-weight: bold; font-size: 0.9em; margin-bottom: 4px; display: flex; align-items: center; }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        .score-badge {
            background: #333;
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            margin-right: 8px;
            font-weight: bold;
            min-width: 24px;
            text-align: center;
        }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.85em; }
        .downhill { color: #28a745; font-weight: bold; }
        .uphill { color: #dc3545; font-weight: bold; }
        .leaflet-routing-container {
            max-height: 400px;
            overflow-y: auto;
        }
        .hover-marker {
            position: relative;
            z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <div id="route-options">
        <label style="font-weight: bold; cursor: pointer;">
            <input type="checkbox" id="avoid-tolls"> Avoid Tolls
        </label>
    </div>
    
    <div id="grade-stats">
        <!-- Stats will be injected here via JS -->
    </div>

    <div id="elevation-container">
        <div id="elevation-msg"></div>
        <canvas id="elevationChart"></canvas>
    </div>

    <script>
        // 1. Initialize Map
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        });

        // Google Map Layer with Traffic overlay
        const googleTrafficLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=m,traffic&x={x}&y={y}&z={z}', {
            maxZoom: 20,
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            attribution: '© Google'
        });

        const map = L.map('map', {
            center: [41.176, 29.590], // Updated center to Şile, Turkey
            zoom: 13,
            layers: [osmLayer] // Default to OSM
        });

        // Marker for showing chart hover position on map
        const hoverMarker = L.marker([0, 0], {
            icon: L.divIcon({
                className: 'hover-marker',
                html: '<div style="width: 10px; height: 10px; background: red; border-radius: 50%; border: 2px solid white;"></div>',
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            })
        }).addTo(map);
        hoverMarker.setOpacity(0); // Hide initially

        // Add control to switch between layers
        L.control.layers({
            "OpenStreetMap": osmLayer,
            "Google Traffic": googleTrafficLayer
        }).addTo(map);

        // Show coordinates on map click
        map.on('click', function(e) {
            L.popup()
                .setLatLng(e.latlng)
                .setContent(`Lat: ${e.latlng.lat.toFixed(5)}<br>Lng: ${e.latlng.lng.toFixed(5)}`)
                .openOn(map);
        });

        // 2. Initialize Chart.js instance
        let elevationChart = null;
        const ctx = document.getElementById('elevationChart').getContext('2d');
        const elevationContainer = document.getElementById('elevation-container');
        const elevationMsg = document.getElementById('elevation-msg');
        const gradeStatsContainer = document.getElementById('grade-stats');

        // Define colors for different routes
        const routeColors = ['#007bff', '#dc3545', '#28a745', '#ffc107', '#6f42c1'];

        // Custom Router to support exclude parameter (e.g. tolls)
        L.Routing.OSRMv1WithExclude = L.Routing.OSRMv1.extend({
            options: {
                exclude: null // e.g., 'toll'
            },
            buildRouteUrl: function(waypoints, options) {
                var url = L.Routing.OSRMv1.prototype.buildRouteUrl.call(this, waypoints, options);
                
                // Only append if exclude is set and not empty
                if (this.options.exclude) {
                    var separator = url.indexOf('?') === -1 ? '?' : '&';
                    url += separator + 'exclude=' + this.options.exclude;
                }
                
                console.log('Generated Route URL:', url);
                return url;
            }
        });

        function showMessage(msg) {
            elevationContainer.style.display = 'block';
            elevationMsg.style.display = 'block';
            elevationMsg.innerText = msg;
            if (elevationChart) {
                elevationChart.destroy();
                elevationChart = null;
            }
        }

        function updateChart(datasets, allSampledCoords) {
            elevationContainer.style.display = 'block';
            elevationMsg.style.display = 'none';

            if (elevationChart) {
                elevationChart.destroy();
            }

            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            type: 'linear', 
                            title: { display: true, text: 'Distance (km)' },
                            ticks: { maxTicksLimit: 10 }
                        },
                        y: { 
                            title: { display: true, text: 'Elevation (m)' } 
                        }
                    },
                    plugins: {
                        tooltip: { 
                            mode: 'nearest', 
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y}m`;
                                }
                            }
                        },
                        title: { display: true, text: 'Route Elevation Comparison' },
                        legend: { display: true, position: 'top' }
                    },
                    interaction: { mode: 'nearest', axis: 'x', intersect: false },
                    onHover: (event, elements) => {
                        if (elements && elements.length > 0) {
                            const index = elements[0].index;
                            const datasetIndex = elements[0].datasetIndex;
                            
                            // Get coordinates for this point
                            if (allSampledCoords && allSampledCoords[datasetIndex] && allSampledCoords[datasetIndex][index]) {
                                const latlng = allSampledCoords[datasetIndex][index];
                                hoverMarker.setLatLng(latlng);
                                hoverMarker.setOpacity(1);
                            }
                        } else {
                            hoverMarker.setOpacity(0);
                        }
                    }
                }
            });
        }

        function updateGradeStatsUI(allStats) {
            gradeStatsContainer.innerHTML = '';
            
            if (allStats.length === 0) {
                gradeStatsContainer.style.display = 'none';
                return;
            }

            // Sort by score descending to show best route first? 
            // Or keep map order? Let's keep map order but highlight score.
            
            allStats.forEach((stat, index) => {
                const color = routeColors[index % routeColors.length];
                const html = `
                    <div class="route-stat-group">
                        <div class="route-title">
                            <span class="color-dot" style="background-color: ${color}"></span>
                            <span class="score-badge" title="Efficiency Score (0-10)">${stat.score}</span>
                            ${stat.name} (${stat.totalDist} km)
                        </div>
                        <div class="stat-row">
                            <span>Regen (Down): <span class="downhill">${stat.downPct}%</span></span>
                            <span>Power (Up): <span class="uphill">${stat.upPct}%</span></span>
                        </div>
                    </div>
                `;
                gradeStatsContainer.innerHTML += html;
            });
            
            gradeStatsContainer.style.display = 'block';
        }

        // 3. Helper to fetch elevation from Open-Elevation API
        async function getElevationData(coordinates) {
            // Sample coordinates to reduce payload size and stay within URL limits (Open-Meteo GET limit)
            // Reduced to 80 to be safe with URL length limits
            const maxPoints = 80;
            const step = Math.max(1, Math.ceil(coordinates.length / maxPoints));
            const sampledCoords = coordinates.filter((_, i) => i % step === 0);

            const lats = sampledCoords.map(c => c.lat.toFixed(6)).join(',');
            const lngs = sampledCoords.map(c => c.lng.toFixed(6)).join(',');
            
            try {
                // Switch to Open-Meteo API (More reliable than Open-Elevation)
                const response = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`);

                if (!response.ok) throw new Error('Elevation API error: ' + response.statusText);
                
                const data = await response.json();
                // Open-Meteo returns { elevation: [val1, val2, ...] }
                return { elevations: data.elevation, sampledCoords }; 
            } catch (e) {
                console.error("Could not fetch elevation", e);
                return null;
            }
        }

        // 4. Routing Control
        const control = L.Routing.control({
            waypoints: [
                L.latLng(41.16307, 29.57887), // Turkey, Şile, Kumbaba
                L.latLng(41.16989, 29.61860)  // Turkey, Şile, Çavuş
            ],
            routeWhileDragging: true,
            reverseWaypoints: true, // This ensures inputs are filled when markers move
            showAlternatives: true, // Requirement: Alternative routes
            // Explicitly use Custom OSRM router
            router: new L.Routing.OSRMv1WithExclude({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving',
                exclude: null
            }),
            geocoder: L.Control.Geocoder.nominatim(), 
            lineOptions: {
                styles: [{color: routeColors[0], opacity: 0.8, weight: 6}]
            },
            altLineOptions: {
                styles: [{color: '#6c757d', opacity: 0.6, weight: 4}] // Default grey for alts on map
            },
            createMarker: function(i, wp, nWps) {
                // Create a standard Leaflet marker
                const marker = L.marker(wp.latLng, {
                    draggable: true,
                    icon: L.icon({
                        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    })
                });

                // Add a popup with a remove button
                marker.bindPopup(function() {
                    const container = document.createElement('div');
                    const btn = document.createElement('button');
                    btn.innerText = 'Remove Waypoint';
                    btn.style.backgroundColor = '#dc3545';
                    btn.style.color = 'white';
                    btn.style.border = 'none';
                    btn.style.padding = '5px 10px';
                    btn.style.cursor = 'pointer';
                    btn.style.borderRadius = '4px';
                    
                    btn.onclick = function() {
                        control.spliceWaypoints(i, 1);
                        map.closePopup();
                    };
                    
                    container.appendChild(btn);
                    return container;
                });

                return marker;
            }
        }).addTo(map);

        // Handle Toll Checkbox
        document.getElementById('avoid-tolls').addEventListener('change', function(e) {
            const router = control.getRouter();
            // OSRM uses 'toll' (singular) for the exclude parameter
            router.options.exclude = e.target.checked ? 'toll' : null;
            console.log('Toggling tolls. Exclude:', router.options.exclude);
            control.route(); // Recalculate route
        });

        // Handle Routing Errors
        control.on('routingerror', function(e) {
            console.error('Routing error event:', e);
            let msg = "Routing Error: ";
            
            // Attempt to parse OSRM error response
            if (e.error && e.error.responseText) {
                try {
                    const response = JSON.parse(e.error.responseText);
                    if (response.message) {
                        msg += response.message;
                    }
                    // Check for specific OSRM error regarding exclude flags
                    if (response.code === 'InvalidValue' && response.message.includes('Exclude')) {
                        msg += "<br><br><strong>Note:</strong> The free public routing server does not support avoiding tolls. Please uncheck the box.";
                        
                        // Automatically reset the UI to prevent getting stuck
                        document.getElementById('avoid-tolls').checked = false;
                        control.getRouter().options.exclude = null;
                        
                        // Optional: Retry automatically after a short delay
                        // setTimeout(() => control.route(), 2000);
                    }
                } catch (err) {
                    msg += "HTTP " + e.error.status;
                }
            } else if (e.error && e.error.message) {
                msg += e.error.message;
            } else if (e.error && e.error.status) {
                msg += "HTTP Status " + e.error.status;
            } else {
                msg += "Unknown error (check console)";
            }
            showMessage(msg);
        });

        // 5. Handle Routes Found (Process ALL routes)
        async function processRoutes(routes) {
            console.log(`Found ${routes.length} routes.`);
            showMessage("Loading elevation data for " + routes.length + " route(s)...");
            gradeStatsContainer.style.display = 'none';
            
            const chartDatasets = [];
            const statsData = [];
            const allSampledCoords = []; // Store coords for chart interaction

            // Process each route sequentially to avoid overwhelming API
            for (let i = 0; i < routes.length; i++) {
                const route = routes[i];
                const coordinates = route.coordinates;
                const routeName = route.name || `Route ${i + 1}`;
                const color = routeColors[i % routeColors.length];

                // Fetch Elevation
                const data = await getElevationData(coordinates);
                
                if (data && data.elevations) {
                    const elevations = data.elevations;
                    const sampledCoords = data.sampledCoords;
                    allSampledCoords.push(sampledCoords); // Save for interaction
                    
                    // Calculate distances and stats
                    const dataPoints = []; // {x: dist, y: elev}
                    let currentDist = 0;
                    let downhillDist = 0;
                    let uphillDist = 0;

                    for (let j = 0; j < sampledCoords.length; j++) {
                        if (j > 0) {
                            const distSeg = sampledCoords[j].distanceTo(sampledCoords[j-1]);
                            currentDist += distSeg;
                            
                            const elevDiff = elevations[j] - elevations[j-1];
                            if (elevDiff < 0) downhillDist += distSeg;
                            else if (elevDiff > 0) uphillDist += distSeg;
                        }
                        dataPoints.push({ x: parseFloat((currentDist / 1000).toFixed(2)), y: elevations[j] });
                    }

                    // Prepare Chart Dataset
                    chartDatasets.push({
                        label: routeName,
                        data: dataPoints,
                        borderColor: color,
                        backgroundColor: color + '33', // Transparent fill
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0, // Hide points by default
                        pointHoverRadius: 6, // Show on hover
                        borderWidth: 2
                    });

                    // Prepare Stats (Store raw values for score calc)
                    const totalDist = currentDist;
                    statsData.push({
                        name: routeName,
                        totalDist: (totalDist / 1000).toFixed(1),
                        rawDist: totalDist,
                        rawDown: downhillDist,
                        rawUp: uphillDist,
                        downPct: totalDist > 0 ? ((downhillDist / totalDist) * 100).toFixed(0) : 0,
                        upPct: totalDist > 0 ? ((uphillDist / totalDist) * 100).toFixed(0) : 0
                    });
                } else {
                    console.warn(`Failed to get elevation for route ${i}`);
                    allSampledCoords.push([]); // Keep index sync
                }
            }

            // Calculate Scores
            if (statsData.length > 0) {
                // Find shortest distance for baseline
                const minDist = Math.min(...statsData.map(s => s.rawDist));

                statsData.forEach(stat => {
                    // 1. Distance Score (Base 10): Shorter is better. 
                    // If route is 2x longer than shortest, score drops to 5.
                    const distScore = (minDist / stat.rawDist) * 10;

                    // 2. Gradient Score: Net Regen Factor
                    // (Down - Up) / Total. 
                    // Positive means net downhill (good). Negative means net uphill (bad).
                    // Multiplier 20 gives it reasonable weight (e.g. 5% net diff = +/- 1 point)
                    const netGradient = (stat.rawDown - stat.rawUp) / stat.rawDist;
                    const gradScore = netGradient * 20;

                    // Final Score
                    let finalScore = distScore + gradScore;
                    
                    // Clamp to 0-10 range (allow slightly over 10 for exceptional downhill routes)
                    finalScore = Math.max(0, Math.min(10, finalScore));
                    
                    stat.score = finalScore.toFixed(1);
                });

                updateChart(chartDatasets, allSampledCoords);
                updateGradeStatsUI(statsData);
            } else {
                showMessage("No elevation data available. (API might be unreachable or route too short)");
            }
        }

        // Map Hover Interaction (Map -> Chart)
        map.on('mousemove', function(e) {
            if (!elevationChart || !globalSampledCoords.length) return;

            let minDistance = Infinity;
            let bestMatch = null;

            // Iterate all routes
            globalSampledCoords.forEach((routeCoords, datasetIndex) => {
                routeCoords.forEach((coord, index) => {
                    const dist = e.latlng.distanceTo(coord);
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestMatch = { datasetIndex, index };
                    }
                });
            });

            // If close enough (e.g. 500 meters to account for sampling gaps)
            if (minDistance < 500 && bestMatch) {
                const meta = elevationChart.getDatasetMeta(bestMatch.datasetIndex);
                const point = meta.data[bestMatch.index];
                
                if (point) {
                    elevationChart.setActiveElements([{ datasetIndex: bestMatch.datasetIndex, index: bestMatch.index }]);
                    elevationChart.tooltip.setActiveElements([{ datasetIndex: bestMatch.datasetIndex, index: bestMatch.index }]);
                    elevationChart.update();
                }
            } else {
                elevationChart.setActiveElements([]);
                elevationChart.tooltip.setActiveElements([]);
                elevationChart.update();
            }
        });

        control.on('routesfound', function(e) {
            // Process all found routes
            processRoutes(e.routes);
        });
    </script>
</body>
</html>
